local loop = require('delay_loop')
local ws2812= require('ws2812')

local moduleName = ...
-- _G[moduleName] = M
-- local pin=7
local M = {}
M.__index = M

function M.new(pin,numLED)
    local self=setmetatable({},M)
    self.pin=pin
    self.buffer=""
    self.tbuf=""
    self:reset(numLED)
    return self
end


local function log(x)
    local n = 1000.0
    return n * ((( x ^( 1/n)) ) - 1)
end

function M:write(buf)
  self.buffer=buf
  self:show()
end

function M:show()
  if not(self.buffer == self.tbuf)then
      print("writing led "..self.pin)
      print("show buffer")
      print(self.buffer:byte(1,3))
      ws2812.write(self.pin,self.buffer)
      self.tbuf = self.buffer
      print("end show")
  end
end

function M:reset(numLED)
  -- not required but provides baseline
  self.buffer=string.char(0,0,0):rep(numLED)
  self:show()
end

function M:fade(to_array,fader_delay,fader_steps)
  local numled = #to_array
  local from_array = self.buffer
  local step_delay = ( fader_delay )/ fader_steps
  local log_base = log(fader_steps)

  local function run_fade(current_step)
    print("begin fade")
    local previous_weight
    local current_weight
    local fader_weight
    -- this only implements logarithmic decay
    current_weight = 100 - ( 100 * (log(fader_steps - current_step + 1) / log_base))
    previous_weight = 100 - ( 100 * (log(current_step) / log_base))
    fader_weight = current_weight + previous_weight
    -- send this fader step to the led interface
    self.buffer = "" 
    for i=1,numled,3 do
      if not from_array:byte(i) then from_array =from_array.. string.char(0,0,0) end

      local r = ( ( (to_array:byte(i) * current_weight)+(from_array:byte(i) * previous_weight) ) / fader_weight )
      local g = ( ( (to_array:byte(i+1) * current_weight)+(from_array:byte(i+1) * previous_weight) ) / fader_weight )
      local b = ( ( (to_array:byte(i+2) * current_weight)+(from_array:byte(i+2) * previous_weight) ) / fader_weight )
      self.buffer = self.buffer .. string.char(r,g,b)
      print("end prepare ",self.buffer:byte(1),self.buffer:byte(2),self.buffer:byte(3))
    end
    self:show()
  end
  --             start,max_steps,increment,delay,callback
  loop.stop()
  loop.start(1,fader_steps,1,step_delay,run_fade)
end

return M
